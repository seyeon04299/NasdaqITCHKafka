<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>C++ Project Template: OrderSamples Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">C++ Project Template
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classOrderSamples-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">OrderSamples Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="OrderSamples_8h_source.html">OrderSamples.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aa43f643216788297ac2a064a2f912657"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structOrder.html">Order</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrderSamples.html#aa43f643216788297ac2a064a2f912657">AtAuction</a> (std::string action, double quantity, double price)</td></tr>
<tr class="memdesc:aa43f643216788297ac2a064a2f912657"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make sure to test using only your paper trading account when applicable. A good way of finding out if an order type/exchange combination is possible is by trying to place such order manually using the TWS. Before contacting our API support team please refer to the available documentation.  <a href="classOrderSamples.html#aa43f643216788297ac2a064a2f912657">More...</a><br /></td></tr>
<tr class="separator:aa43f643216788297ac2a064a2f912657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2814bd9a395cf65bcc7b6e4234ed8e66"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structOrder.html">Order</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrderSamples.html#a2814bd9a395cf65bcc7b6e4234ed8e66">Discretionary</a> (std::string action, double quantity, double price, double discretionaryAmount)</td></tr>
<tr class="memdesc:a2814bd9a395cf65bcc7b6e4234ed8e66"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Discretionary order is a limit order submitted with a hidden, specified 'discretionary' amount off the limit price which may be used to increase the price range over which the limit order is eligible to execute. The market sees only the limit price. Products: STK  <a href="classOrderSamples.html#a2814bd9a395cf65bcc7b6e4234ed8e66">More...</a><br /></td></tr>
<tr class="separator:a2814bd9a395cf65bcc7b6e4234ed8e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab854168d242f96152f0929eed9ef2c0b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structOrder.html">Order</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrderSamples.html#ab854168d242f96152f0929eed9ef2c0b">MarketOrder</a> (std::string action, double quantity)</td></tr>
<tr class="memdesc:ab854168d242f96152f0929eed9ef2c0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Market order is an order to buy or sell at the market bid or offer price. A market order may increase the likelihood of a fill and the speed of execution, but unlike the Limit order a Market order provides no price protection and may fill at a price far lower/higher than the current displayed bid/ask. Products: BOND, CFD, EFP, CASH, FUND, FUT, FOP, OPT, STK, WAR  <a href="classOrderSamples.html#ab854168d242f96152f0929eed9ef2c0b">More...</a><br /></td></tr>
<tr class="separator:ab854168d242f96152f0929eed9ef2c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29db24e0ffb95b50762ff68f9dc6af60"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structOrder.html">Order</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrderSamples.html#a29db24e0ffb95b50762ff68f9dc6af60">MarketIfTouched</a> (std::string action, double quantity, double price)</td></tr>
<tr class="memdesc:a29db24e0ffb95b50762ff68f9dc6af60"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Market if Touched (MIT) is an order to buy (or sell) a contract below (or above) the market. Its purpose is to take advantage of sudden or unexpected changes in share or other prices and provides investors with a trigger price to set an order in motion. Investors may be waiting for excessive strength (or weakness) to cease, which might be represented by a specific price point. MIT orders can be used to determine whether or not to enter the market once a specific price level has been achieved. This order is held in the system until the trigger price is touched, and is then submitted as a market order. An MIT order is similar to a stop order, except that an MIT sell order is placed above the current market price, and a stop sell order is placed below Products: BOND, CFD, CASH, FUT, FOP, OPT, STK, WAR  <a href="classOrderSamples.html#a29db24e0ffb95b50762ff68f9dc6af60">More...</a><br /></td></tr>
<tr class="separator:a29db24e0ffb95b50762ff68f9dc6af60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58d6e0557866d7c3611262302857049e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structOrder.html">Order</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrderSamples.html#a58d6e0557866d7c3611262302857049e">MarketOnClose</a> (std::string action, double quantity)</td></tr>
<tr class="memdesc:a58d6e0557866d7c3611262302857049e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Market-on-Close (MOC) order is a market order that is submitted to execute as close to the closing price as possible. Products: CFD, FUT, STK, WAR  <a href="classOrderSamples.html#a58d6e0557866d7c3611262302857049e">More...</a><br /></td></tr>
<tr class="separator:a58d6e0557866d7c3611262302857049e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65583640a76c52f21d91a25797b97774"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structOrder.html">Order</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrderSamples.html#a65583640a76c52f21d91a25797b97774">MarketOnOpen</a> (std::string action, double quantity)</td></tr>
<tr class="memdesc:a65583640a76c52f21d91a25797b97774"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Market-on-Open (MOO) order combines a market order with the OPG time in force to create an order that is automatically submitted at the market's open and fills at the market price. Products: CFD, STK, OPT, WAR  <a href="classOrderSamples.html#a65583640a76c52f21d91a25797b97774">More...</a><br /></td></tr>
<tr class="separator:a65583640a76c52f21d91a25797b97774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf1634bd4a2f806711310be77a2f90fc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structOrder.html">Order</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrderSamples.html#adf1634bd4a2f806711310be77a2f90fc">MidpointMatch</a> (std::string action, double quantity)</td></tr>
<tr class="memdesc:adf1634bd4a2f806711310be77a2f90fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">ISE Midpoint Match (MPM) orders always execute at the midpoint of the NBBO. You can submit market and limit orders direct-routed to ISE for MPM execution. Market orders execute at the midpoint whenever an eligible contra-order is available. Limit orders execute only when the midpoint price is better than the limit price. Standard MPM orders are completely anonymous. Products: STK  <a href="classOrderSamples.html#adf1634bd4a2f806711310be77a2f90fc">More...</a><br /></td></tr>
<tr class="separator:adf1634bd4a2f806711310be77a2f90fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63fe5a53a03712c07d7dfdb534209836"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structOrder.html">Order</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrderSamples.html#a63fe5a53a03712c07d7dfdb534209836">Midprice</a> (std::string action, double quantity, double priceCap)</td></tr>
<tr class="separator:a63fe5a53a03712c07d7dfdb534209836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a284cb72b2c8c17fabc72f0ba3e34514b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structOrder.html">Order</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrderSamples.html#a284cb72b2c8c17fabc72f0ba3e34514b">PeggedToMarket</a> (std::string action, double quantity, double marketOffset)</td></tr>
<tr class="memdesc:a284cb72b2c8c17fabc72f0ba3e34514b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pegged-to-market order is designed to maintain a purchase price relative to the national best offer (NBO) or a sale price relative to the national best bid (NBB). Depending on the width of the quote, this order may be passive or aggressive. The trader creates the order by entering a limit price which defines the worst limit price that they are willing to accept. Next, the trader enters an offset amount which computes the active limit price as follows: Sell order price = Bid price + offset amount Buy order price = Ask price - offset amount Products: STK  <a href="classOrderSamples.html#a284cb72b2c8c17fabc72f0ba3e34514b">More...</a><br /></td></tr>
<tr class="separator:a284cb72b2c8c17fabc72f0ba3e34514b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a565e14617de8e27a1f8648dc6bfc645c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structOrder.html">Order</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrderSamples.html#a565e14617de8e27a1f8648dc6bfc645c">PeggedToStock</a> (std::string action, double quantity, double delta, double stockReferencePrice, double startingPrice)</td></tr>
<tr class="memdesc:a565e14617de8e27a1f8648dc6bfc645c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Pegged to Stock order continually adjusts the option order price by the product of a signed user-define delta and the change of the option's underlying stock price. The delta is entered as an absolute and assumed to be positive for calls and negative for puts. A buy or sell call order price is determined by adding the delta times a change in an underlying stock price to a specified starting price for the call. To determine the change in price, the stock reference price is subtracted from the current NBBO midpoint. The Stock Reference Price can be defined by the user, or defaults to the NBBO midpoint at the time of the order if no reference price is entered. You may also enter a high/low stock price range which cancels the order when reached. The delta times the change in stock price will be rounded to the nearest penny in favor of the order. Products: OPT  <a href="classOrderSamples.html#a565e14617de8e27a1f8648dc6bfc645c">More...</a><br /></td></tr>
<tr class="separator:a565e14617de8e27a1f8648dc6bfc645c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accbfda5f82157bec0357d350fbdf9f3b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structOrder.html">Order</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrderSamples.html#accbfda5f82157bec0357d350fbdf9f3b">RelativePeggedToPrimary</a> (std::string action, double quantity, double priceCap, double offsetAmount)</td></tr>
<tr class="memdesc:accbfda5f82157bec0357d350fbdf9f3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relative (a.k.a. Pegged-to-Primary) orders provide a means for traders to seek a more aggressive price than the National Best Bid and Offer (NBBO). By acting as liquidity providers, and placing more aggressive bids and offers than the current best bids and offers, traders increase their odds of filling their order. Quotes are automatically adjusted as the markets move, to remain aggressive. For a buy order, your bid is pegged to the NBB by a more aggressive offset, and if the NBB moves up, your bid will also move up. If the NBB moves down, there will be no adjustment because your bid will become even more aggressive and execute. For sales, your offer is pegged to the NBO by a more aggressive offset, and if the NBO moves down, your offer will also move down. If the NBO moves up, there will be no adjustment because your offer will become more aggressive and execute. In addition to the offset, you can define an absolute cap, which works like a limit price, and will prevent your order from being executed above or below a specified level. Stocks, Options and Futures - not available on paper trading Products: CFD, STK, OPT, FUT  <a href="classOrderSamples.html#accbfda5f82157bec0357d350fbdf9f3b">More...</a><br /></td></tr>
<tr class="separator:accbfda5f82157bec0357d350fbdf9f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ae872326d9853580cab7cb07cbed3c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structOrder.html">Order</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrderSamples.html#ae2ae872326d9853580cab7cb07cbed3c">SweepToFill</a> (std::string action, double quantity, double price)</td></tr>
<tr class="memdesc:ae2ae872326d9853580cab7cb07cbed3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sweep-to-fill orders are useful when a trader values speed of execution over price. A sweep-to-fill order identifies the best price and the exact quantity offered/available at that price, and transmits the corresponding portion of your order for immediate execution. Simultaneously it identifies the next best price and quantity offered/available, and submits the matching quantity of your order for immediate execution. Products: CFD, STK, WAR Supported Exchanges: SMART  <a href="classOrderSamples.html#ae2ae872326d9853580cab7cb07cbed3c">More...</a><br /></td></tr>
<tr class="separator:ae2ae872326d9853580cab7cb07cbed3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d57e3eaa2649a76c9b5e23aac90d85c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structOrder.html">Order</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrderSamples.html#a5d57e3eaa2649a76c9b5e23aac90d85c">AuctionLimit</a> (std::string action, double quantity, double price, int auctionStrategy)</td></tr>
<tr class="memdesc:a5d57e3eaa2649a76c9b5e23aac90d85c"><td class="mdescLeft">&#160;</td><td class="mdescRight">For option orders routed to the Boston Options Exchange (BOX) you may elect to participate in the BOX's price improvement auction in pennies. All BOX-directed price improvement orders are immediately sent from Interactive Brokers to the BOX order book, and when the terms allow, IB will evaluate it for inclusion in a price improvement auction based on price and volume priority. In the auction, your order will have priority over broker-dealer price improvement orders at the same price. An Auction Limit order at a specified price. Use of a limit order ensures that you will not receive an execution at a price less favorable than the limit price. Enter limit orders in penny increments with your auction improvement amount computed as the difference between your limit order price and the nearest listed increment. Products: OPT Supported Exchanges: BOX  <a href="classOrderSamples.html#a5d57e3eaa2649a76c9b5e23aac90d85c">More...</a><br /></td></tr>
<tr class="separator:a5d57e3eaa2649a76c9b5e23aac90d85c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a286c3f298c08721b65903f23e2346f3b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structOrder.html">Order</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrderSamples.html#a286c3f298c08721b65903f23e2346f3b">AuctionPeggedToStock</a> (std::string action, double quantity, double startingPrice, double delta)</td></tr>
<tr class="memdesc:a286c3f298c08721b65903f23e2346f3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">For option orders routed to the Boston Options Exchange (BOX) you may elect to participate in the BOX's price improvement auction in pennies. All BOX-directed price improvement orders are immediately sent from Interactive Brokers to the BOX order book, and when the terms allow, IB will evaluate it for inclusion in a price improvement auction based on price and volume priority. In the auction, your order will have priority over broker-dealer price improvement orders at the same price. An Auction Pegged to Stock order adjusts the order price by the product of a signed delta (which is entered as an absolute and assumed to be positive for calls, negative for puts) and the change of the option's underlying stock price. A buy or sell call order price is determined by adding the delta times a change in an underlying stock price change to a specified starting price for the call. To determine the change in price, a stock reference price (NBBO midpoint at the time of the order is assumed if no reference price is entered) is subtracted from the current NBBO midpoint. A stock range may also be entered that cancels an order when reached. The delta times the change in stock price will be rounded to the nearest penny in favor of the order and will be used as your auction improvement amount. Products: OPT Supported Exchanges: BOX  <a href="classOrderSamples.html#a286c3f298c08721b65903f23e2346f3b">More...</a><br /></td></tr>
<tr class="separator:a286c3f298c08721b65903f23e2346f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25217e58b21201c9438504145ea8a5f4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structOrder.html">Order</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrderSamples.html#a25217e58b21201c9438504145ea8a5f4">AuctionRelative</a> (std::string action, double quantity, double offset)</td></tr>
<tr class="memdesc:a25217e58b21201c9438504145ea8a5f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">For option orders routed to the Boston Options Exchange (BOX) you may elect to participate in the BOX's price improvement auction in pennies. All BOX-directed price improvement orders are immediately sent from Interactive Brokers to the BOX order book, and when the terms allow, IB will evaluate it for inclusion in a price improvement auction based on price and volume priority. In the auction, your order will have priority over broker-dealer price improvement orders at the same price. An Auction Relative order that adjusts the order price by the product of a signed delta (which is entered as an absolute and assumed to be positive for calls, negative for puts) and the change of the option's underlying stock price. A buy or sell call order price is determined by adding the delta times a change in an underlying stock price change to a specified starting price for the call. To determine the change in price, a stock reference price (NBBO midpoint at the time of the order is assumed if no reference price is entered) is subtracted from the current NBBO midpoint. A stock range may also be entered that cancels an order when reached. The delta times the change in stock price will be rounded to the nearest penny in favor of the order and will be used as your auction improvement amount. Products: OPT Supported Exchanges: BOX  <a href="classOrderSamples.html#a25217e58b21201c9438504145ea8a5f4">More...</a><br /></td></tr>
<tr class="separator:a25217e58b21201c9438504145ea8a5f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7821edf9259e85464d75ebe5c908d092"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structOrder.html">Order</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrderSamples.html#a7821edf9259e85464d75ebe5c908d092">Block</a> (std::string action, double quantity, double price)</td></tr>
<tr class="memdesc:a7821edf9259e85464d75ebe5c908d092"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Block attribute is used for large volume option orders on ISE that consist of at least 50 contracts. To execute large-volume orders over time without moving the market, use the Accumulate/Distribute algorithm. Products: OPT  <a href="classOrderSamples.html#a7821edf9259e85464d75ebe5c908d092">More...</a><br /></td></tr>
<tr class="separator:a7821edf9259e85464d75ebe5c908d092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdd4838d9b8aa73a1b84db87c546e1a1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structOrder.html">Order</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrderSamples.html#acdd4838d9b8aa73a1b84db87c546e1a1">BoxTop</a> (std::string action, double quantity)</td></tr>
<tr class="memdesc:acdd4838d9b8aa73a1b84db87c546e1a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Box Top order executes as a market order at the current best price. If the order is only partially filled, the remainder is submitted as a limit order with the limit price equal to the price at which the filled portion of the order executed. Products: OPT Supported Exchanges: BOX  <a href="classOrderSamples.html#acdd4838d9b8aa73a1b84db87c546e1a1">More...</a><br /></td></tr>
<tr class="separator:acdd4838d9b8aa73a1b84db87c546e1a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb72cdbb5cf364721e47276460ba03d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structOrder.html">Order</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrderSamples.html#adfb72cdbb5cf364721e47276460ba03d">LimitOrder</a> (std::string action, double quantity, double limitPrice)</td></tr>
<tr class="memdesc:adfb72cdbb5cf364721e47276460ba03d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Limit order is an order to buy or sell at a specified price or better. The Limit order ensures that if the order fills, it will not fill at a price less favorable than your limit price, but it does not guarantee a fill. Products: BOND, CFD, CASH, FUT, FOP, OPT, STK, WAR  <a href="classOrderSamples.html#adfb72cdbb5cf364721e47276460ba03d">More...</a><br /></td></tr>
<tr class="separator:adfb72cdbb5cf364721e47276460ba03d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76e7d6819c8dd57e562c923993b8825d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structOrder.html">Order</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrderSamples.html#a76e7d6819c8dd57e562c923993b8825d">LimitOrderWithCashQty</a> (std::string action, double limitPrice, double cashQty)</td></tr>
<tr class="memdesc:a76e7d6819c8dd57e562c923993b8825d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forex orders can be placed in denomination of second currency in pair using cashQty field Requires TWS or IBG 963+ <a href="https://www.interactivebrokers.com/en/index.php?f=23876#963-02">https://www.interactivebrokers.com/en/index.php?f=23876#963-02</a>  <a href="classOrderSamples.html#a76e7d6819c8dd57e562c923993b8825d">More...</a><br /></td></tr>
<tr class="separator:a76e7d6819c8dd57e562c923993b8825d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7831a17028b33428aec0dcd46a150ac7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structOrder.html">Order</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrderSamples.html#a7831a17028b33428aec0dcd46a150ac7">LimitIfTouched</a> (std::string action, double quantity, double limitPrice, double triggerPrice)</td></tr>
<tr class="memdesc:a7831a17028b33428aec0dcd46a150ac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Limit if Touched is an order to buy (or sell) a contract at a specified price or better, below (or above) the market. This order is held in the system until the trigger price is touched. An LIT order is similar to a stop limit order, except that an LIT sell order is placed above the current market price, and a stop limit sell order is placed below. Products: BOND, CFD, CASH, FUT, FOP, OPT, STK, WAR  <a href="classOrderSamples.html#a7831a17028b33428aec0dcd46a150ac7">More...</a><br /></td></tr>
<tr class="separator:a7831a17028b33428aec0dcd46a150ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa74d75e86a95e264b52f09b3cfe63337"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structOrder.html">Order</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrderSamples.html#aa74d75e86a95e264b52f09b3cfe63337">LimitOnClose</a> (std::string action, double quantity, double limitPrice)</td></tr>
<tr class="memdesc:aa74d75e86a95e264b52f09b3cfe63337"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Limit-on-close (LOC) order will be submitted at the close and will execute if the closing price is at or better than the submitted limit price. Products: CFD, FUT, STK, WAR  <a href="classOrderSamples.html#aa74d75e86a95e264b52f09b3cfe63337">More...</a><br /></td></tr>
<tr class="separator:aa74d75e86a95e264b52f09b3cfe63337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f6e1f549bddaf5403d11ca350ba9d9a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structOrder.html">Order</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrderSamples.html#a2f6e1f549bddaf5403d11ca350ba9d9a">LimitOnOpen</a> (std::string action, double quantity, double limitPrice)</td></tr>
<tr class="memdesc:a2f6e1f549bddaf5403d11ca350ba9d9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Limit-on-Open (LOO) order combines a limit order with the OPG time in force to create an order that is submitted at the market's open, and that will only execute at the specified limit price or better. Orders are filled in accordance with specific exchange rules. Products: CFD, STK, OPT, WAR  <a href="classOrderSamples.html#a2f6e1f549bddaf5403d11ca350ba9d9a">More...</a><br /></td></tr>
<tr class="separator:a2f6e1f549bddaf5403d11ca350ba9d9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e27b91c834c802b744abbf3f34fa7a7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structOrder.html">Order</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrderSamples.html#a2e27b91c834c802b744abbf3f34fa7a7">PassiveRelative</a> (std::string action, double quantity, double offset)</td></tr>
<tr class="memdesc:a2e27b91c834c802b744abbf3f34fa7a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Passive Relative orders provide a means for traders to seek a less aggressive price than the National Best Bid and Offer (NBBO) while keeping the order pegged to the best bid (for a buy) or ask (for a sell). The order price is automatically adjusted as the markets move to keep the order less aggressive. For a buy order, your order price is pegged to the NBB by a less aggressive offset, and if the NBB moves up, your bid will also move up. If the NBB moves down, there will be no adjustment because your bid will become aggressive and execute. For a sell order, your price is pegged to the NBO by a less aggressive offset, and if the NBO moves down, your offer will also move down. If the NBO moves up, there will be no adjustment because your offer will become aggressive and execute. In addition to the offset, you can define an absolute cap, which works like a limit price, and will prevent your order from being executed above or below a specified level. The Passive Relative order is similar to the Relative/Pegged-to-Primary order, except that the Passive relative subtracts the offset from the bid and the Relative adds the offset to the bid. Products: STK, WAR  <a href="classOrderSamples.html#a2e27b91c834c802b744abbf3f34fa7a7">More...</a><br /></td></tr>
<tr class="separator:a2e27b91c834c802b744abbf3f34fa7a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a94f5f1a3a0f2374e2999799ce73a0a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structOrder.html">Order</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrderSamples.html#a9a94f5f1a3a0f2374e2999799ce73a0a">PeggedToMidpoint</a> (std::string action, double quantity, double offset, double limitPrice)</td></tr>
<tr class="memdesc:a9a94f5f1a3a0f2374e2999799ce73a0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pegged-to-midpoint order provides a means for traders to seek a price at the midpoint of the National Best Bid and Offer (NBBO). The price automatically adjusts to peg the midpoint as the markets move, to remain aggressive. For a buy order, your bid is pegged to the NBBO midpoint and the order price adjusts automatically to continue to peg the midpoint if the market moves. The price only adjusts to be more aggressive. If the market moves in the opposite direction, the order will execute. Products: STK  <a href="classOrderSamples.html#a9a94f5f1a3a0f2374e2999799ce73a0a">More...</a><br /></td></tr>
<tr class="separator:a9a94f5f1a3a0f2374e2999799ce73a0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83f36b2ee398c1d4a0243fdf4a0b41f7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrderSamples.html#a83f36b2ee398c1d4a0243fdf4a0b41f7">BracketOrder</a> (int parentOrderId, <a class="el" href="structOrder.html">Order</a> &amp;parent, <a class="el" href="structOrder.html">Order</a> &amp;takeProfit, <a class="el" href="structOrder.html">Order</a> &amp;stopLoss, std::string action, double quantity, double limitPrice, double takeProfitLimitPrice, double stopLossPrice)</td></tr>
<tr class="memdesc:a83f36b2ee398c1d4a0243fdf4a0b41f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bracket orders are designed to help limit your loss and lock in a profit by "bracketing" an order with two opposite-side orders. A BUY order is bracketed by a high-side sell limit order and a low-side sell stop order. A SELL order is bracketed by a high-side buy stop order and a low side buy limit order. Products: CFD, BAG, FOP, CASH, FUT, OPT, STK, WAR  <a href="classOrderSamples.html#a83f36b2ee398c1d4a0243fdf4a0b41f7">More...</a><br /></td></tr>
<tr class="separator:a83f36b2ee398c1d4a0243fdf4a0b41f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4488a0c525d88cf62ba6fdaeef21bb68"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structOrder.html">Order</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrderSamples.html#a4488a0c525d88cf62ba6fdaeef21bb68">MarketToLimit</a> (std::string action, double quantity)</td></tr>
<tr class="memdesc:a4488a0c525d88cf62ba6fdaeef21bb68"><td class="mdescLeft">&#160;</td><td class="mdescRight">[bracket]  <a href="classOrderSamples.html#a4488a0c525d88cf62ba6fdaeef21bb68">More...</a><br /></td></tr>
<tr class="separator:a4488a0c525d88cf62ba6fdaeef21bb68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a625fcc0e9e436d3c3bd24a3015081c17"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structOrder.html">Order</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrderSamples.html#a625fcc0e9e436d3c3bd24a3015081c17">MarketWithProtection</a> (std::string action, double quantity)</td></tr>
<tr class="memdesc:a625fcc0e9e436d3c3bd24a3015081c17"><td class="mdescLeft">&#160;</td><td class="mdescRight">This order type is useful for futures traders using Globex. A Market with Protection order is a market order that will be cancelled and resubmitted as a limit order if the entire order does not immediately execute at the market price. The limit price is set by Globex to be close to the current market price, slightly higher for a sell order and lower for a buy order. Products: FUT, FOP  <a href="classOrderSamples.html#a625fcc0e9e436d3c3bd24a3015081c17">More...</a><br /></td></tr>
<tr class="separator:a625fcc0e9e436d3c3bd24a3015081c17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d5d8bfeb7882bcad899521e2676717f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structOrder.html">Order</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrderSamples.html#a5d5d8bfeb7882bcad899521e2676717f">Stop</a> (std::string action, double quantity, double stopPrice)</td></tr>
<tr class="memdesc:a5d5d8bfeb7882bcad899521e2676717f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Stop order is an instruction to submit a buy or sell market order if and when the user-specified stop trigger price is attained or penetrated. A Stop order is not guaranteed a specific execution price and may execute significantly away from its stop price. A Sell Stop order is always placed below the current market price and is typically used to limit a loss or protect a profit on a long stock position. A Buy Stop order is always placed above the current market price. It is typically used to limit a loss or help protect a profit on a short sale. Products: CFD, BAG, CASH, FUT, FOP, OPT, STK, WAR  <a href="classOrderSamples.html#a5d5d8bfeb7882bcad899521e2676717f">More...</a><br /></td></tr>
<tr class="separator:a5d5d8bfeb7882bcad899521e2676717f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1811c4184d1fec96e83556c8322ce21f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structOrder.html">Order</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrderSamples.html#a1811c4184d1fec96e83556c8322ce21f">StopLimit</a> (std::string action, double quantity, double limitPrice, double stopPrice)</td></tr>
<tr class="memdesc:a1811c4184d1fec96e83556c8322ce21f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Stop-Limit order is an instruction to submit a buy or sell limit order when the user-specified stop trigger price is attained or penetrated. The order has two basic components: the stop price and the limit price. When a trade has occurred at or through the stop price, the order becomes executable and enters the market as a limit order, which is an order to buy or sell at a specified price or better. Products: CFD, CASH, FUT, FOP, OPT, STK, WAR  <a href="classOrderSamples.html#a1811c4184d1fec96e83556c8322ce21f">More...</a><br /></td></tr>
<tr class="separator:a1811c4184d1fec96e83556c8322ce21f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb52f689a49c20040d28a2967afde91e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structOrder.html">Order</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrderSamples.html#aeb52f689a49c20040d28a2967afde91e">StopWithProtection</a> (std::string action, double quantity, double stopPrice)</td></tr>
<tr class="memdesc:aeb52f689a49c20040d28a2967afde91e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Stop with Protection order combines the functionality of a stop limit order with a market with protection order. The order is set to trigger at a specified stop price. When the stop price is penetrated, the order is triggered as a market with protection order, which means that it will fill within a specified protected price range equal to the trigger price +/- the exchange-defined protection point range. Any portion of the order that does not fill within this protected range is submitted as a limit order at the exchange-defined trigger price +/- the protection points. Products: FUT  <a href="classOrderSamples.html#aeb52f689a49c20040d28a2967afde91e">More...</a><br /></td></tr>
<tr class="separator:aeb52f689a49c20040d28a2967afde91e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a09ccc59e19800534786f01e32fbde"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structOrder.html">Order</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrderSamples.html#af4a09ccc59e19800534786f01e32fbde">TrailingStop</a> (std::string action, double quantity, double trailingPercent, double trailStopPrice)</td></tr>
<tr class="memdesc:af4a09ccc59e19800534786f01e32fbde"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sell trailing stop order sets the stop price at a fixed amount below the market price with an attached "trailing" amount. As the market price rises, the stop price rises by the trail amount, but if the stock price falls, the stop loss price doesn't change, and a market order is submitted when the stop price is hit. This technique is designed to allow an investor to specify a limit on the maximum possible loss, without setting a limit on the maximum possible gain. "Buy" trailing stop orders are the mirror image of sell trailing stop orders, and are most appropriate for use in falling markets. Products: CFD, CASH, FOP, FUT, OPT, STK, WAR  <a href="classOrderSamples.html#af4a09ccc59e19800534786f01e32fbde">More...</a><br /></td></tr>
<tr class="separator:af4a09ccc59e19800534786f01e32fbde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bc6059b761e9bcefcaa7b1d0d5d5b26"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structOrder.html">Order</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrderSamples.html#a1bc6059b761e9bcefcaa7b1d0d5d5b26">TrailingStopLimit</a> (std::string action, double quantity, double lmtPriceOffset, double trailingAmount, double trailStopPrice)</td></tr>
<tr class="memdesc:a1bc6059b761e9bcefcaa7b1d0d5d5b26"><td class="mdescLeft">&#160;</td><td class="mdescRight">A trailing stop limit order is designed to allow an investor to specify a limit on the maximum possible loss, without setting a limit on the maximum possible gain. A SELL trailing stop limit moves with the market price, and continually recalculates the stop trigger price at a fixed amount below the market price, based on the user-defined "trailing" amount. The limit order price is also continually recalculated based on the limit offset. As the market price rises, both the stop price and the limit price rise by the trail amount and limit offset respectively, but if the stock price falls, the stop price remains unchanged, and when the stop price is hit a limit order is submitted at the last calculated limit price. A "Buy" trailing stop limit order is the mirror image of a sell trailing stop limit, and is generally used in falling markets. Products: BOND, CFD, CASH, FUT, FOP, OPT, STK, WAR  <a href="classOrderSamples.html#a1bc6059b761e9bcefcaa7b1d0d5d5b26">More...</a><br /></td></tr>
<tr class="separator:a1bc6059b761e9bcefcaa7b1d0d5d5b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9211033356cb60896b503e229107206"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structOrder.html">Order</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrderSamples.html#ad9211033356cb60896b503e229107206">ComboLimitOrder</a> (std::string action, double quantity, double limitPrice, bool nonGuaranteed)</td></tr>
<tr class="memdesc:ad9211033356cb60896b503e229107206"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create combination orders that include options, stock and futures legs (stock legs can be included if the order is routed through SmartRouting). Although a combination/spread order is constructed of separate legs, it is executed as a single transaction if it is routed directly to an exchange. For combination orders that are SmartRouted, each leg may be executed separately to ensure best execution. Products: OPT, STK, FUT  <a href="classOrderSamples.html#ad9211033356cb60896b503e229107206">More...</a><br /></td></tr>
<tr class="separator:ad9211033356cb60896b503e229107206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2717cccea46d58d3b3cc929807313c6e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structOrder.html">Order</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrderSamples.html#a2717cccea46d58d3b3cc929807313c6e">ComboMarketOrder</a> (std::string action, double quantity, bool nonGuaranteed)</td></tr>
<tr class="memdesc:a2717cccea46d58d3b3cc929807313c6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create combination orders that include options, stock and futures legs (stock legs can be included if the order is routed through SmartRouting). Although a combination/spread order is constructed of separate legs, it is executed as a single transaction if it is routed directly to an exchange. For combination orders that are SmartRouted, each leg may be executed separately to ensure best execution. Products: OPT, STK, FUT  <a href="classOrderSamples.html#a2717cccea46d58d3b3cc929807313c6e">More...</a><br /></td></tr>
<tr class="separator:a2717cccea46d58d3b3cc929807313c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c628c53ee0e3511f7ef6ba8fddfb569"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structOrder.html">Order</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrderSamples.html#a5c628c53ee0e3511f7ef6ba8fddfb569">LimitOrderForComboWithLegPrices</a> (std::string action, double quantity, std::vector&lt; double &gt; legprices, bool nonGuaranteed)</td></tr>
<tr class="memdesc:a5c628c53ee0e3511f7ef6ba8fddfb569"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create combination orders that include options, stock and futures legs (stock legs can be included if the order is routed through SmartRouting). Although a combination/spread order is constructed of separate legs, it is executed as a single transaction if it is routed directly to an exchange. For combination orders that are SmartRouted, each leg may be executed separately to ensure best execution. Products: OPT, STK, FUT  <a href="classOrderSamples.html#a5c628c53ee0e3511f7ef6ba8fddfb569">More...</a><br /></td></tr>
<tr class="separator:a5c628c53ee0e3511f7ef6ba8fddfb569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c6b76c8e3e63651eec9dbf3254de2db"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structOrder.html">Order</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrderSamples.html#a7c6b76c8e3e63651eec9dbf3254de2db">RelativeLimitOrder</a> (std::string action, double quantity, double limitPrice, bool nonGuaranteed)</td></tr>
<tr class="memdesc:a7c6b76c8e3e63651eec9dbf3254de2db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create combination orders that include options, stock and futures legs (stock legs can be included if the order is routed through SmartRouting). Although a combination/spread order is constructed of separate legs, it is executed as a single transaction if it is routed directly to an exchange. For combination orders that are SmartRouted, each leg may be executed separately to ensure best execution. Products: OPT, STK, FUT  <a href="classOrderSamples.html#a7c6b76c8e3e63651eec9dbf3254de2db">More...</a><br /></td></tr>
<tr class="separator:a7c6b76c8e3e63651eec9dbf3254de2db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6745611b0ad3f61241b5224021e2888"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structOrder.html">Order</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrderSamples.html#af6745611b0ad3f61241b5224021e2888">RelativeMarketCombo</a> (std::string action, double quantity, bool nonGuaranteed)</td></tr>
<tr class="memdesc:af6745611b0ad3f61241b5224021e2888"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create combination orders that include options, stock and futures legs (stock legs can be included if the order is routed through SmartRouting). Although a combination/spread order is constructed of separate legs, it is executed as a single transaction if it is routed directly to an exchange. For combination orders that are SmartRouted, each leg may be executed separately to ensure best execution. Products: OPT, STK, FUT  <a href="classOrderSamples.html#af6745611b0ad3f61241b5224021e2888">More...</a><br /></td></tr>
<tr class="separator:af6745611b0ad3f61241b5224021e2888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc89cb64477378679f0bf2bf2c9d7ec"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrderSamples.html#a9fc89cb64477378679f0bf2bf2c9d7ec">OneCancelsAll</a> (std::string ocaGroup, <a class="el" href="structOrder.html">Order</a> &amp;ocaOrder, int ocaType)</td></tr>
<tr class="memdesc:a9fc89cb64477378679f0bf2bf2c9d7ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">One-Cancels All (OCA) order type allows an investor to place multiple and possibly unrelated orders assigned to a group. The aim is to complete just one of the orders, which in turn will cause TWS to cancel the remaining orders. The investor may submit several orders aimed at taking advantage of the most desirable price within the group. Completion of one piece of the group order causes cancellation of the remaining group orders while partial completion causes the group to rebalance. An investor might desire to sell 1000 shares of only ONE of three positions held above prevailing market prices. The OCA order group allows the investor to enter prices at specified target levels and if one is completed, the other two will automatically cancel. Alternatively, an investor may wish to take a LONG position in eMini S&amp;P stock index futures in a falling market or else SELL US treasury futures at a more favorable price. Grouping the two orders using an OCA order type offers the investor two chance to enter a similar position, while only running the risk of taking on a single position. Products: BOND, CASH, FUT, FOP, STK, OPT, WAR  <a href="classOrderSamples.html#a9fc89cb64477378679f0bf2bf2c9d7ec">More...</a><br /></td></tr>
<tr class="separator:a9fc89cb64477378679f0bf2bf2c9d7ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b53ea59f1fea8f46e495c3eb3613508"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structOrder.html">Order</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrderSamples.html#a5b53ea59f1fea8f46e495c3eb3613508">Volatility</a> (std::string action, double quantity, double volatilityPercent, int volatilityType)</td></tr>
<tr class="memdesc:a5b53ea59f1fea8f46e495c3eb3613508"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specific to US options, investors are able to create and enter Volatility-type orders for options and combinations rather than price orders. Option traders may wish to trade and position for movements in the price of the option determined by its implied volatility. Because implied volatility is a key determinant of the premium on an option, traders position in specific contract months in an effort to take advantage of perceived changes in implied volatility arising before, during or after earnings or when company specific or broad market volatility is predicted to change. In order to create a Volatility order, clients must first create a Volatility Trader page from the Trading Tools menu and as they enter option contracts, premiums will display in percentage terms rather than premium. The buy/sell process is the same as for regular orders priced in premium terms except that the client can limit the volatility level they are willing to pay or receive. Products: FOP, OPT  <a href="classOrderSamples.html#a5b53ea59f1fea8f46e495c3eb3613508">More...</a><br /></td></tr>
<tr class="separator:a5b53ea59f1fea8f46e495c3eb3613508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1bfb9ada028672ffe118840de132233"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structOrder.html">Order</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrderSamples.html#af1bfb9ada028672ffe118840de132233">MarketFHedge</a> (int parentOrderId, std::string action)</td></tr>
<tr class="memdesc:af1bfb9ada028672ffe118840de132233"><td class="mdescLeft">&#160;</td><td class="mdescRight">[fhedge]  <a href="classOrderSamples.html#af1bfb9ada028672ffe118840de132233">More...</a><br /></td></tr>
<tr class="separator:af1bfb9ada028672ffe118840de132233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86cfe33a37fee4a3ca81f3daf8dda60d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structOrder.html">Order</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrderSamples.html#a86cfe33a37fee4a3ca81f3daf8dda60d">PeggedToBenchmark</a> (std::string action, double quantity, double startingPrice, bool peggedChangeAmountDecrease, double peggedChangeAmount, double referenceChangeAmount, int referenceConId, std::string referenceExchange, double stockReferencePrice, double referenceContractLowerRange, double referenceContractUpperRange)</td></tr>
<tr class="memdesc:a86cfe33a37fee4a3ca81f3daf8dda60d"><td class="mdescLeft">&#160;</td><td class="mdescRight">[fhedge]  <a href="classOrderSamples.html#a86cfe33a37fee4a3ca81f3daf8dda60d">More...</a><br /></td></tr>
<tr class="separator:a86cfe33a37fee4a3ca81f3daf8dda60d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41bcf8f2cac4542ef9c5990b6356b407"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structOrder.html">Order</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrderSamples.html#a41bcf8f2cac4542ef9c5990b6356b407">AttachAdjustableToStop</a> (<a class="el" href="structOrder.html">Order</a> parent, double attachedOrderStopPrice, double triggerPrice, double adjustStopPrice)</td></tr>
<tr class="separator:a41bcf8f2cac4542ef9c5990b6356b407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeb03e315c869592737af0ff077cdc42"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structOrder.html">Order</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrderSamples.html#abeb03e315c869592737af0ff077cdc42">AttachAdjustableToStopLimit</a> (<a class="el" href="structOrder.html">Order</a> parent, double attachedOrderStopPrice, double triggerPrice, double adjustStopPrice, double adjustedStopLimitPrice)</td></tr>
<tr class="separator:abeb03e315c869592737af0ff077cdc42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ff100a1b943f01bbb6900fdb8f40df8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structOrder.html">Order</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrderSamples.html#a0ff100a1b943f01bbb6900fdb8f40df8">AttachAdjustableToTrail</a> (<a class="el" href="structOrder.html">Order</a> parent, double attachedOrderStopPrice, double triggerPrice, double adjustStopPrice, double adjustedTrailAmount, int trailUnit)</td></tr>
<tr class="separator:a0ff100a1b943f01bbb6900fdb8f40df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21dfbf48228f724a70f9e3ee6fcfc9dd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structOrder.html">Order</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrderSamples.html#a21dfbf48228f724a70f9e3ee6fcfc9dd">WhatIfLimitOrder</a> (std::string action, double quantity, double limitPrice)</td></tr>
<tr class="separator:a21dfbf48228f724a70f9e3ee6fcfc9dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab13f09a2d5a291c9c32f17c989129d3c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOrderCondition.html">OrderCondition</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrderSamples.html#ab13f09a2d5a291c9c32f17c989129d3c">Price_Condition</a> (int conId, std::string exchange, double price, bool isMore, bool isConjunction)</td></tr>
<tr class="separator:ab13f09a2d5a291c9c32f17c989129d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ab828baed6fb9af6362ff4fe3b626df"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOrderCondition.html">OrderCondition</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrderSamples.html#a9ab828baed6fb9af6362ff4fe3b626df">Execution_Condition</a> (std::string symbol, std::string secType, std::string exchange, bool isConjunction)</td></tr>
<tr class="separator:a9ab828baed6fb9af6362ff4fe3b626df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a3511425ea8d8d108b4f25db56c820c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOrderCondition.html">OrderCondition</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrderSamples.html#a4a3511425ea8d8d108b4f25db56c820c">Margin_Condition</a> (int percent, bool isMore, bool isConjunction)</td></tr>
<tr class="separator:a4a3511425ea8d8d108b4f25db56c820c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3391fe60af6c780e122bf79ce941febd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOrderCondition.html">OrderCondition</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrderSamples.html#a3391fe60af6c780e122bf79ce941febd">Percent_Change_Condition</a> (double pctChange, int conId, std::string exchange, bool isMore, bool isConjunction)</td></tr>
<tr class="separator:a3391fe60af6c780e122bf79ce941febd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e3e9b8abc552eaf98ac049aac42f8d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOrderCondition.html">OrderCondition</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrderSamples.html#a34e3e9b8abc552eaf98ac049aac42f8d">Time_Condition</a> (std::string time, bool isMore, bool isConjunction)</td></tr>
<tr class="separator:a34e3e9b8abc552eaf98ac049aac42f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8433a1c43fd13b6e73a3edd53e0bbce"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOrderCondition.html">OrderCondition</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrderSamples.html#aa8433a1c43fd13b6e73a3edd53e0bbce">Volume_Condition</a> (int conId, std::string exchange, bool isMore, int volume, bool isConjunction)</td></tr>
<tr class="separator:aa8433a1c43fd13b6e73a3edd53e0bbce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa43f643216788297ac2a064a2f912657"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa43f643216788297ac2a064a2f912657">&#9670;&nbsp;</a></span>AtAuction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structOrder.html">Order</a> OrderSamples::AtAuction </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quantity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>price</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make sure to test using only your paper trading account when applicable. A good way of finding out if an order type/exchange combination is possible is by trying to place such order manually using the TWS. Before contacting our API support team please refer to the available documentation. </p>
<p>An auction order is entered into the electronic trading system during the pre-market opening period for execution at the Calculated Opening Price (COP). If your order is not filled on the open, the order is re-submitted as a limit order with the limit price set to the COP or the best bid/ask after the market opens. Products: FUT, STK</p>
<p>[auction]</p>
<p>[auction]</p>

</div>
</div>
<a id="a41bcf8f2cac4542ef9c5990b6356b407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41bcf8f2cac4542ef9c5990b6356b407">&#9670;&nbsp;</a></span>AttachAdjustableToStop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structOrder.html">Order</a> OrderSamples::AttachAdjustableToStop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structOrder.html">Order</a>&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>attachedOrderStopPrice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>triggerPrice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>adjustStopPrice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>[adjustable_stop]</p>
<p>[adjustable_stop]</p>

</div>
</div>
<a id="abeb03e315c869592737af0ff077cdc42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeb03e315c869592737af0ff077cdc42">&#9670;&nbsp;</a></span>AttachAdjustableToStopLimit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structOrder.html">Order</a> OrderSamples::AttachAdjustableToStopLimit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structOrder.html">Order</a>&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>attachedOrderStopPrice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>triggerPrice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>adjustStopPrice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>adjustedStopLimitPrice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>[adjustable_stop_limit]</p>
<p>[adjustable_stop_limit]</p>

</div>
</div>
<a id="a0ff100a1b943f01bbb6900fdb8f40df8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ff100a1b943f01bbb6900fdb8f40df8">&#9670;&nbsp;</a></span>AttachAdjustableToTrail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structOrder.html">Order</a> OrderSamples::AttachAdjustableToTrail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structOrder.html">Order</a>&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>attachedOrderStopPrice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>triggerPrice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>adjustStopPrice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>adjustedTrailAmount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>trailUnit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>[adjustable_trail]</p>
<p>[adjustable_trail]</p>

</div>
</div>
<a id="a5d57e3eaa2649a76c9b5e23aac90d85c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d57e3eaa2649a76c9b5e23aac90d85c">&#9670;&nbsp;</a></span>AuctionLimit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structOrder.html">Order</a> OrderSamples::AuctionLimit </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quantity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>price</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>auctionStrategy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For option orders routed to the Boston Options Exchange (BOX) you may elect to participate in the BOX's price improvement auction in pennies. All BOX-directed price improvement orders are immediately sent from Interactive Brokers to the BOX order book, and when the terms allow, IB will evaluate it for inclusion in a price improvement auction based on price and volume priority. In the auction, your order will have priority over broker-dealer price improvement orders at the same price. An Auction Limit order at a specified price. Use of a limit order ensures that you will not receive an execution at a price less favorable than the limit price. Enter limit orders in penny increments with your auction improvement amount computed as the difference between your limit order price and the nearest listed increment. Products: OPT Supported Exchanges: BOX </p>
<p>[auction_limit]</p>
<p>[auction_limit]</p>

</div>
</div>
<a id="a286c3f298c08721b65903f23e2346f3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a286c3f298c08721b65903f23e2346f3b">&#9670;&nbsp;</a></span>AuctionPeggedToStock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structOrder.html">Order</a> OrderSamples::AuctionPeggedToStock </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quantity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>startingPrice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For option orders routed to the Boston Options Exchange (BOX) you may elect to participate in the BOX's price improvement auction in pennies. All BOX-directed price improvement orders are immediately sent from Interactive Brokers to the BOX order book, and when the terms allow, IB will evaluate it for inclusion in a price improvement auction based on price and volume priority. In the auction, your order will have priority over broker-dealer price improvement orders at the same price. An Auction Pegged to Stock order adjusts the order price by the product of a signed delta (which is entered as an absolute and assumed to be positive for calls, negative for puts) and the change of the option's underlying stock price. A buy or sell call order price is determined by adding the delta times a change in an underlying stock price change to a specified starting price for the call. To determine the change in price, a stock reference price (NBBO midpoint at the time of the order is assumed if no reference price is entered) is subtracted from the current NBBO midpoint. A stock range may also be entered that cancels an order when reached. The delta times the change in stock price will be rounded to the nearest penny in favor of the order and will be used as your auction improvement amount. Products: OPT Supported Exchanges: BOX </p>
<p>[auction_pegged_stock]</p>
<p>[auction_pegged_stock]</p>

</div>
</div>
<a id="a25217e58b21201c9438504145ea8a5f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25217e58b21201c9438504145ea8a5f4">&#9670;&nbsp;</a></span>AuctionRelative()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structOrder.html">Order</a> OrderSamples::AuctionRelative </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quantity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For option orders routed to the Boston Options Exchange (BOX) you may elect to participate in the BOX's price improvement auction in pennies. All BOX-directed price improvement orders are immediately sent from Interactive Brokers to the BOX order book, and when the terms allow, IB will evaluate it for inclusion in a price improvement auction based on price and volume priority. In the auction, your order will have priority over broker-dealer price improvement orders at the same price. An Auction Relative order that adjusts the order price by the product of a signed delta (which is entered as an absolute and assumed to be positive for calls, negative for puts) and the change of the option's underlying stock price. A buy or sell call order price is determined by adding the delta times a change in an underlying stock price change to a specified starting price for the call. To determine the change in price, a stock reference price (NBBO midpoint at the time of the order is assumed if no reference price is entered) is subtracted from the current NBBO midpoint. A stock range may also be entered that cancels an order when reached. The delta times the change in stock price will be rounded to the nearest penny in favor of the order and will be used as your auction improvement amount. Products: OPT Supported Exchanges: BOX </p>
<p>[auction_relative]</p>
<p>[auction_relative]</p>

</div>
</div>
<a id="a7821edf9259e85464d75ebe5c908d092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7821edf9259e85464d75ebe5c908d092">&#9670;&nbsp;</a></span>Block()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structOrder.html">Order</a> OrderSamples::Block </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quantity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>price</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The Block attribute is used for large volume option orders on ISE that consist of at least 50 contracts. To execute large-volume orders over time without moving the market, use the Accumulate/Distribute algorithm. Products: OPT </p>

</div>
</div>
<a id="acdd4838d9b8aa73a1b84db87c546e1a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdd4838d9b8aa73a1b84db87c546e1a1">&#9670;&nbsp;</a></span>BoxTop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structOrder.html">Order</a> OrderSamples::BoxTop </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quantity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A Box Top order executes as a market order at the current best price. If the order is only partially filled, the remainder is submitted as a limit order with the limit price equal to the price at which the filled portion of the order executed. Products: OPT Supported Exchanges: BOX </p>

</div>
</div>
<a id="a83f36b2ee398c1d4a0243fdf4a0b41f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83f36b2ee398c1d4a0243fdf4a0b41f7">&#9670;&nbsp;</a></span>BracketOrder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OrderSamples::BracketOrder </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>parentOrderId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structOrder.html">Order</a> &amp;&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structOrder.html">Order</a> &amp;&#160;</td>
          <td class="paramname"><em>takeProfit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structOrder.html">Order</a> &amp;&#160;</td>
          <td class="paramname"><em>stopLoss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quantity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>limitPrice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>takeProfitLimitPrice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>stopLossPrice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bracket orders are designed to help limit your loss and lock in a profit by "bracketing" an order with two opposite-side orders. A BUY order is bracketed by a high-side sell limit order and a low-side sell stop order. A SELL order is bracketed by a high-side buy stop order and a low side buy limit order. Products: CFD, BAG, FOP, CASH, FUT, OPT, STK, WAR </p>
<p>[bracket] </p>

</div>
</div>
<a id="ad9211033356cb60896b503e229107206"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9211033356cb60896b503e229107206">&#9670;&nbsp;</a></span>ComboLimitOrder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structOrder.html">Order</a> OrderSamples::ComboLimitOrder </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quantity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>limitPrice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>nonGuaranteed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create combination orders that include options, stock and futures legs (stock legs can be included if the order is routed through SmartRouting). Although a combination/spread order is constructed of separate legs, it is executed as a single transaction if it is routed directly to an exchange. For combination orders that are SmartRouted, each leg may be executed separately to ensure best execution. Products: OPT, STK, FUT </p>

</div>
</div>
<a id="a2717cccea46d58d3b3cc929807313c6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2717cccea46d58d3b3cc929807313c6e">&#9670;&nbsp;</a></span>ComboMarketOrder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structOrder.html">Order</a> OrderSamples::ComboMarketOrder </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quantity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>nonGuaranteed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create combination orders that include options, stock and futures legs (stock legs can be included if the order is routed through SmartRouting). Although a combination/spread order is constructed of separate legs, it is executed as a single transaction if it is routed directly to an exchange. For combination orders that are SmartRouted, each leg may be executed separately to ensure best execution. Products: OPT, STK, FUT </p>

</div>
</div>
<a id="a2814bd9a395cf65bcc7b6e4234ed8e66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2814bd9a395cf65bcc7b6e4234ed8e66">&#9670;&nbsp;</a></span>Discretionary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structOrder.html">Order</a> OrderSamples::Discretionary </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quantity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>price</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>discretionaryAmount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A Discretionary order is a limit order submitted with a hidden, specified 'discretionary' amount off the limit price which may be used to increase the price range over which the limit order is eligible to execute. The market sees only the limit price. Products: STK </p>
<p>[discretionary]</p>
<p>[discretionary]</p>

</div>
</div>
<a id="a9ab828baed6fb9af6362ff4fe3b626df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ab828baed6fb9af6362ff4fe3b626df">&#9670;&nbsp;</a></span>Execution_Condition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOrderCondition.html">OrderCondition</a> * OrderSamples::Execution_Condition </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>symbol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>secType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>exchange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isConjunction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>[execution_condition]</p>
<p>[execution_condition]</p>

</div>
</div>
<a id="a7831a17028b33428aec0dcd46a150ac7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7831a17028b33428aec0dcd46a150ac7">&#9670;&nbsp;</a></span>LimitIfTouched()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structOrder.html">Order</a> OrderSamples::LimitIfTouched </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quantity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>limitPrice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>triggerPrice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A Limit if Touched is an order to buy (or sell) a contract at a specified price or better, below (or above) the market. This order is held in the system until the trigger price is touched. An LIT order is similar to a stop limit order, except that an LIT sell order is placed above the current market price, and a stop limit sell order is placed below. Products: BOND, CFD, CASH, FUT, FOP, OPT, STK, WAR </p>

</div>
</div>
<a id="aa74d75e86a95e264b52f09b3cfe63337"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa74d75e86a95e264b52f09b3cfe63337">&#9670;&nbsp;</a></span>LimitOnClose()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structOrder.html">Order</a> OrderSamples::LimitOnClose </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quantity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>limitPrice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A Limit-on-close (LOC) order will be submitted at the close and will execute if the closing price is at or better than the submitted limit price. Products: CFD, FUT, STK, WAR </p>

</div>
</div>
<a id="a2f6e1f549bddaf5403d11ca350ba9d9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f6e1f549bddaf5403d11ca350ba9d9a">&#9670;&nbsp;</a></span>LimitOnOpen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structOrder.html">Order</a> OrderSamples::LimitOnOpen </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quantity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>limitPrice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A Limit-on-Open (LOO) order combines a limit order with the OPG time in force to create an order that is submitted at the market's open, and that will only execute at the specified limit price or better. Orders are filled in accordance with specific exchange rules. Products: CFD, STK, OPT, WAR </p>

</div>
</div>
<a id="adfb72cdbb5cf364721e47276460ba03d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfb72cdbb5cf364721e47276460ba03d">&#9670;&nbsp;</a></span>LimitOrder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structOrder.html">Order</a> OrderSamples::LimitOrder </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quantity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>limitPrice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A Limit order is an order to buy or sell at a specified price or better. The Limit order ensures that if the order fills, it will not fill at a price less favorable than your limit price, but it does not guarantee a fill. Products: BOND, CFD, CASH, FUT, FOP, OPT, STK, WAR </p>

</div>
</div>
<a id="a5c628c53ee0e3511f7ef6ba8fddfb569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c628c53ee0e3511f7ef6ba8fddfb569">&#9670;&nbsp;</a></span>LimitOrderForComboWithLegPrices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structOrder.html">Order</a> OrderSamples::LimitOrderForComboWithLegPrices </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quantity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>legprices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>nonGuaranteed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create combination orders that include options, stock and futures legs (stock legs can be included if the order is routed through SmartRouting). Although a combination/spread order is constructed of separate legs, it is executed as a single transaction if it is routed directly to an exchange. For combination orders that are SmartRouted, each leg may be executed separately to ensure best execution. Products: OPT, STK, FUT </p>

</div>
</div>
<a id="a76e7d6819c8dd57e562c923993b8825d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76e7d6819c8dd57e562c923993b8825d">&#9670;&nbsp;</a></span>LimitOrderWithCashQty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structOrder.html">Order</a> OrderSamples::LimitOrderWithCashQty </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>limitPrice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cashQty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forex orders can be placed in denomination of second currency in pair using cashQty field Requires TWS or IBG 963+ <a href="https://www.interactivebrokers.com/en/index.php?f=23876#963-02">https://www.interactivebrokers.com/en/index.php?f=23876#963-02</a> </p>

</div>
</div>
<a id="a4a3511425ea8d8d108b4f25db56c820c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a3511425ea8d8d108b4f25db56c820c">&#9670;&nbsp;</a></span>Margin_Condition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOrderCondition.html">OrderCondition</a> * OrderSamples::Margin_Condition </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>percent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isMore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isConjunction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>[margin_condition]</p>
<p>[margin_condition]</p>

</div>
</div>
<a id="af1bfb9ada028672ffe118840de132233"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1bfb9ada028672ffe118840de132233">&#9670;&nbsp;</a></span>MarketFHedge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structOrder.html">Order</a> OrderSamples::MarketFHedge </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>parentOrderId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>[fhedge] </p>

</div>
</div>
<a id="a29db24e0ffb95b50762ff68f9dc6af60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29db24e0ffb95b50762ff68f9dc6af60">&#9670;&nbsp;</a></span>MarketIfTouched()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structOrder.html">Order</a> OrderSamples::MarketIfTouched </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quantity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>price</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A Market if Touched (MIT) is an order to buy (or sell) a contract below (or above) the market. Its purpose is to take advantage of sudden or unexpected changes in share or other prices and provides investors with a trigger price to set an order in motion. Investors may be waiting for excessive strength (or weakness) to cease, which might be represented by a specific price point. MIT orders can be used to determine whether or not to enter the market once a specific price level has been achieved. This order is held in the system until the trigger price is touched, and is then submitted as a market order. An MIT order is similar to a stop order, except that an MIT sell order is placed above the current market price, and a stop sell order is placed below Products: BOND, CFD, CASH, FUT, FOP, OPT, STK, WAR </p>
<p>[market_if_touched]</p>
<p>[market_if_touched]</p>

</div>
</div>
<a id="a58d6e0557866d7c3611262302857049e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58d6e0557866d7c3611262302857049e">&#9670;&nbsp;</a></span>MarketOnClose()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structOrder.html">Order</a> OrderSamples::MarketOnClose </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quantity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A Market-on-Close (MOC) order is a market order that is submitted to execute as close to the closing price as possible. Products: CFD, FUT, STK, WAR </p>
<p>[market_on_close]</p>
<p>[market_on_close]</p>

</div>
</div>
<a id="a65583640a76c52f21d91a25797b97774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65583640a76c52f21d91a25797b97774">&#9670;&nbsp;</a></span>MarketOnOpen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structOrder.html">Order</a> OrderSamples::MarketOnOpen </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quantity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A Market-on-Open (MOO) order combines a market order with the OPG time in force to create an order that is automatically submitted at the market's open and fills at the market price. Products: CFD, STK, OPT, WAR </p>
<p>[market_on_open]</p>
<p>[market_on_open]</p>

</div>
</div>
<a id="ab854168d242f96152f0929eed9ef2c0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab854168d242f96152f0929eed9ef2c0b">&#9670;&nbsp;</a></span>MarketOrder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structOrder.html">Order</a> OrderSamples::MarketOrder </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quantity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A Market order is an order to buy or sell at the market bid or offer price. A market order may increase the likelihood of a fill and the speed of execution, but unlike the Limit order a Market order provides no price protection and may fill at a price far lower/higher than the current displayed bid/ask. Products: BOND, CFD, EFP, CASH, FUND, FUT, FOP, OPT, STK, WAR </p>
<p>[market]</p>
<p>[market]</p>

</div>
</div>
<a id="a4488a0c525d88cf62ba6fdaeef21bb68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4488a0c525d88cf62ba6fdaeef21bb68">&#9670;&nbsp;</a></span>MarketToLimit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structOrder.html">Order</a> OrderSamples::MarketToLimit </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quantity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>[bracket] </p>
<p>Products:CFD, FUT, FOP, OPT, STK, WAR A Market-to-Limit (MTL) order is submitted as a market order to execute at the current best market price. If the order is only partially filled, the remainder of the order is canceled and re-submitted as a limit order with the limit price equal to the price at which the filled portion of the order executed.</p>

</div>
</div>
<a id="a625fcc0e9e436d3c3bd24a3015081c17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a625fcc0e9e436d3c3bd24a3015081c17">&#9670;&nbsp;</a></span>MarketWithProtection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structOrder.html">Order</a> OrderSamples::MarketWithProtection </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quantity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This order type is useful for futures traders using Globex. A Market with Protection order is a market order that will be cancelled and resubmitted as a limit order if the entire order does not immediately execute at the market price. The limit price is set by Globex to be close to the current market price, slightly higher for a sell order and lower for a buy order. Products: FUT, FOP </p>

</div>
</div>
<a id="adf1634bd4a2f806711310be77a2f90fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf1634bd4a2f806711310be77a2f90fc">&#9670;&nbsp;</a></span>MidpointMatch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structOrder.html">Order</a> OrderSamples::MidpointMatch </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quantity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ISE Midpoint Match (MPM) orders always execute at the midpoint of the NBBO. You can submit market and limit orders direct-routed to ISE for MPM execution. Market orders execute at the midpoint whenever an eligible contra-order is available. Limit orders execute only when the midpoint price is better than the limit price. Standard MPM orders are completely anonymous. Products: STK </p>
<p>[midpoint_match]</p>
<p>[midpoint_match]</p>

</div>
</div>
<a id="a63fe5a53a03712c07d7dfdb534209836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63fe5a53a03712c07d7dfdb534209836">&#9670;&nbsp;</a></span>Midprice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structOrder.html">Order</a> OrderSamples::Midprice </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quantity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>priceCap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>
<p>[midprice]</p>
<p>[midprice]</p>

</div>
</div>
<a id="a9fc89cb64477378679f0bf2bf2c9d7ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fc89cb64477378679f0bf2bf2c9d7ec">&#9670;&nbsp;</a></span>OneCancelsAll()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OrderSamples::OneCancelsAll </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>ocaGroup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structOrder.html">Order</a> &amp;&#160;</td>
          <td class="paramname"><em>ocaOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ocaType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>One-Cancels All (OCA) order type allows an investor to place multiple and possibly unrelated orders assigned to a group. The aim is to complete just one of the orders, which in turn will cause TWS to cancel the remaining orders. The investor may submit several orders aimed at taking advantage of the most desirable price within the group. Completion of one piece of the group order causes cancellation of the remaining group orders while partial completion causes the group to rebalance. An investor might desire to sell 1000 shares of only ONE of three positions held above prevailing market prices. The OCA order group allows the investor to enter prices at specified target levels and if one is completed, the other two will automatically cancel. Alternatively, an investor may wish to take a LONG position in eMini S&amp;P stock index futures in a falling market or else SELL US treasury futures at a more favorable price. Grouping the two orders using an OCA order type offers the investor two chance to enter a similar position, while only running the risk of taking on a single position. Products: BOND, CASH, FUT, FOP, STK, OPT, WAR </p>

</div>
</div>
<a id="a2e27b91c834c802b744abbf3f34fa7a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e27b91c834c802b744abbf3f34fa7a7">&#9670;&nbsp;</a></span>PassiveRelative()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structOrder.html">Order</a> OrderSamples::PassiveRelative </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quantity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Passive Relative orders provide a means for traders to seek a less aggressive price than the National Best Bid and Offer (NBBO) while keeping the order pegged to the best bid (for a buy) or ask (for a sell). The order price is automatically adjusted as the markets move to keep the order less aggressive. For a buy order, your order price is pegged to the NBB by a less aggressive offset, and if the NBB moves up, your bid will also move up. If the NBB moves down, there will be no adjustment because your bid will become aggressive and execute. For a sell order, your price is pegged to the NBO by a less aggressive offset, and if the NBO moves down, your offer will also move down. If the NBO moves up, there will be no adjustment because your offer will become aggressive and execute. In addition to the offset, you can define an absolute cap, which works like a limit price, and will prevent your order from being executed above or below a specified level. The Passive Relative order is similar to the Relative/Pegged-to-Primary order, except that the Passive relative subtracts the offset from the bid and the Relative adds the offset to the bid. Products: STK, WAR </p>

</div>
</div>
<a id="a86cfe33a37fee4a3ca81f3daf8dda60d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86cfe33a37fee4a3ca81f3daf8dda60d">&#9670;&nbsp;</a></span>PeggedToBenchmark()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structOrder.html">Order</a> OrderSamples::PeggedToBenchmark </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quantity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>startingPrice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>peggedChangeAmountDecrease</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>peggedChangeAmount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>referenceChangeAmount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>referenceConId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>referenceExchange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>stockReferencePrice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>referenceContractLowerRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>referenceContractUpperRange</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>[fhedge] </p>
<p>[pegged_benchmark]</p>
<p>[pegged_benchmark]</p>

</div>
</div>
<a id="a284cb72b2c8c17fabc72f0ba3e34514b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a284cb72b2c8c17fabc72f0ba3e34514b">&#9670;&nbsp;</a></span>PeggedToMarket()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structOrder.html">Order</a> OrderSamples::PeggedToMarket </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quantity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>marketOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A pegged-to-market order is designed to maintain a purchase price relative to the national best offer (NBO) or a sale price relative to the national best bid (NBB). Depending on the width of the quote, this order may be passive or aggressive. The trader creates the order by entering a limit price which defines the worst limit price that they are willing to accept. Next, the trader enters an offset amount which computes the active limit price as follows: Sell order price = Bid price + offset amount Buy order price = Ask price - offset amount Products: STK </p>
<p>[pegged_market]</p>
<p>[pegged_market]</p>

</div>
</div>
<a id="a9a94f5f1a3a0f2374e2999799ce73a0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a94f5f1a3a0f2374e2999799ce73a0a">&#9670;&nbsp;</a></span>PeggedToMidpoint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structOrder.html">Order</a> OrderSamples::PeggedToMidpoint </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quantity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>limitPrice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A pegged-to-midpoint order provides a means for traders to seek a price at the midpoint of the National Best Bid and Offer (NBBO). The price automatically adjusts to peg the midpoint as the markets move, to remain aggressive. For a buy order, your bid is pegged to the NBBO midpoint and the order price adjusts automatically to continue to peg the midpoint if the market moves. The price only adjusts to be more aggressive. If the market moves in the opposite direction, the order will execute. Products: STK </p>

</div>
</div>
<a id="a565e14617de8e27a1f8648dc6bfc645c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a565e14617de8e27a1f8648dc6bfc645c">&#9670;&nbsp;</a></span>PeggedToStock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structOrder.html">Order</a> OrderSamples::PeggedToStock </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quantity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>stockReferencePrice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>startingPrice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A Pegged to Stock order continually adjusts the option order price by the product of a signed user-define delta and the change of the option's underlying stock price. The delta is entered as an absolute and assumed to be positive for calls and negative for puts. A buy or sell call order price is determined by adding the delta times a change in an underlying stock price to a specified starting price for the call. To determine the change in price, the stock reference price is subtracted from the current NBBO midpoint. The Stock Reference Price can be defined by the user, or defaults to the NBBO midpoint at the time of the order if no reference price is entered. You may also enter a high/low stock price range which cancels the order when reached. The delta times the change in stock price will be rounded to the nearest penny in favor of the order. Products: OPT </p>
<p>[pegged_stock]</p>
<p>[pegged_stock]</p>

</div>
</div>
<a id="a3391fe60af6c780e122bf79ce941febd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3391fe60af6c780e122bf79ce941febd">&#9670;&nbsp;</a></span>Percent_Change_Condition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOrderCondition.html">OrderCondition</a> * OrderSamples::Percent_Change_Condition </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>pctChange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>conId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>exchange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isMore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isConjunction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>[percentage_condition]</p>
<p>[percentage_condition]</p>

</div>
</div>
<a id="ab13f09a2d5a291c9c32f17c989129d3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab13f09a2d5a291c9c32f17c989129d3c">&#9670;&nbsp;</a></span>Price_Condition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOrderCondition.html">OrderCondition</a> * OrderSamples::Price_Condition </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>conId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>exchange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>price</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isMore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isConjunction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>[price_condition]</p>
<p>[price_condition]</p>

</div>
</div>
<a id="a7c6b76c8e3e63651eec9dbf3254de2db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c6b76c8e3e63651eec9dbf3254de2db">&#9670;&nbsp;</a></span>RelativeLimitOrder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structOrder.html">Order</a> OrderSamples::RelativeLimitOrder </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quantity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>limitPrice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>nonGuaranteed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create combination orders that include options, stock and futures legs (stock legs can be included if the order is routed through SmartRouting). Although a combination/spread order is constructed of separate legs, it is executed as a single transaction if it is routed directly to an exchange. For combination orders that are SmartRouted, each leg may be executed separately to ensure best execution. Products: OPT, STK, FUT </p>

</div>
</div>
<a id="af6745611b0ad3f61241b5224021e2888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6745611b0ad3f61241b5224021e2888">&#9670;&nbsp;</a></span>RelativeMarketCombo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structOrder.html">Order</a> OrderSamples::RelativeMarketCombo </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quantity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>nonGuaranteed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create combination orders that include options, stock and futures legs (stock legs can be included if the order is routed through SmartRouting). Although a combination/spread order is constructed of separate legs, it is executed as a single transaction if it is routed directly to an exchange. For combination orders that are SmartRouted, each leg may be executed separately to ensure best execution. Products: OPT, STK, FUT </p>

</div>
</div>
<a id="accbfda5f82157bec0357d350fbdf9f3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accbfda5f82157bec0357d350fbdf9f3b">&#9670;&nbsp;</a></span>RelativePeggedToPrimary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structOrder.html">Order</a> OrderSamples::RelativePeggedToPrimary </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quantity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>priceCap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>offsetAmount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Relative (a.k.a. Pegged-to-Primary) orders provide a means for traders to seek a more aggressive price than the National Best Bid and Offer (NBBO). By acting as liquidity providers, and placing more aggressive bids and offers than the current best bids and offers, traders increase their odds of filling their order. Quotes are automatically adjusted as the markets move, to remain aggressive. For a buy order, your bid is pegged to the NBB by a more aggressive offset, and if the NBB moves up, your bid will also move up. If the NBB moves down, there will be no adjustment because your bid will become even more aggressive and execute. For sales, your offer is pegged to the NBO by a more aggressive offset, and if the NBO moves down, your offer will also move down. If the NBO moves up, there will be no adjustment because your offer will become more aggressive and execute. In addition to the offset, you can define an absolute cap, which works like a limit price, and will prevent your order from being executed above or below a specified level. Stocks, Options and Futures - not available on paper trading Products: CFD, STK, OPT, FUT </p>
<p>[relative_pegged_primary]</p>
<p>[relative_pegged_primary]</p>

</div>
</div>
<a id="a5d5d8bfeb7882bcad899521e2676717f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d5d8bfeb7882bcad899521e2676717f">&#9670;&nbsp;</a></span>Stop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structOrder.html">Order</a> OrderSamples::Stop </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quantity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>stopPrice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A Stop order is an instruction to submit a buy or sell market order if and when the user-specified stop trigger price is attained or penetrated. A Stop order is not guaranteed a specific execution price and may execute significantly away from its stop price. A Sell Stop order is always placed below the current market price and is typically used to limit a loss or protect a profit on a long stock position. A Buy Stop order is always placed above the current market price. It is typically used to limit a loss or help protect a profit on a short sale. Products: CFD, BAG, CASH, FUT, FOP, OPT, STK, WAR </p>

</div>
</div>
<a id="a1811c4184d1fec96e83556c8322ce21f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1811c4184d1fec96e83556c8322ce21f">&#9670;&nbsp;</a></span>StopLimit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structOrder.html">Order</a> OrderSamples::StopLimit </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quantity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>limitPrice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>stopPrice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A Stop-Limit order is an instruction to submit a buy or sell limit order when the user-specified stop trigger price is attained or penetrated. The order has two basic components: the stop price and the limit price. When a trade has occurred at or through the stop price, the order becomes executable and enters the market as a limit order, which is an order to buy or sell at a specified price or better. Products: CFD, CASH, FUT, FOP, OPT, STK, WAR </p>

</div>
</div>
<a id="aeb52f689a49c20040d28a2967afde91e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb52f689a49c20040d28a2967afde91e">&#9670;&nbsp;</a></span>StopWithProtection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structOrder.html">Order</a> OrderSamples::StopWithProtection </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quantity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>stopPrice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A Stop with Protection order combines the functionality of a stop limit order with a market with protection order. The order is set to trigger at a specified stop price. When the stop price is penetrated, the order is triggered as a market with protection order, which means that it will fill within a specified protected price range equal to the trigger price +/- the exchange-defined protection point range. Any portion of the order that does not fill within this protected range is submitted as a limit order at the exchange-defined trigger price +/- the protection points. Products: FUT </p>

</div>
</div>
<a id="ae2ae872326d9853580cab7cb07cbed3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2ae872326d9853580cab7cb07cbed3c">&#9670;&nbsp;</a></span>SweepToFill()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structOrder.html">Order</a> OrderSamples::SweepToFill </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quantity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>price</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sweep-to-fill orders are useful when a trader values speed of execution over price. A sweep-to-fill order identifies the best price and the exact quantity offered/available at that price, and transmits the corresponding portion of your order for immediate execution. Simultaneously it identifies the next best price and quantity offered/available, and submits the matching quantity of your order for immediate execution. Products: CFD, STK, WAR Supported Exchanges: SMART </p>
<p>[sweep_to_fill]</p>
<p>[sweep_to_fill]</p>

</div>
</div>
<a id="a34e3e9b8abc552eaf98ac049aac42f8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34e3e9b8abc552eaf98ac049aac42f8d">&#9670;&nbsp;</a></span>Time_Condition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOrderCondition.html">OrderCondition</a> * OrderSamples::Time_Condition </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isMore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isConjunction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>[time_condition]</p>
<p>[time_condition]</p>

</div>
</div>
<a id="af4a09ccc59e19800534786f01e32fbde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4a09ccc59e19800534786f01e32fbde">&#9670;&nbsp;</a></span>TrailingStop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structOrder.html">Order</a> OrderSamples::TrailingStop </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quantity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>trailingPercent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>trailStopPrice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A sell trailing stop order sets the stop price at a fixed amount below the market price with an attached "trailing" amount. As the market price rises, the stop price rises by the trail amount, but if the stock price falls, the stop loss price doesn't change, and a market order is submitted when the stop price is hit. This technique is designed to allow an investor to specify a limit on the maximum possible loss, without setting a limit on the maximum possible gain. "Buy" trailing stop orders are the mirror image of sell trailing stop orders, and are most appropriate for use in falling markets. Products: CFD, CASH, FOP, FUT, OPT, STK, WAR </p>

</div>
</div>
<a id="a1bc6059b761e9bcefcaa7b1d0d5d5b26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bc6059b761e9bcefcaa7b1d0d5d5b26">&#9670;&nbsp;</a></span>TrailingStopLimit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structOrder.html">Order</a> OrderSamples::TrailingStopLimit </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quantity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lmtPriceOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>trailingAmount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>trailStopPrice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A trailing stop limit order is designed to allow an investor to specify a limit on the maximum possible loss, without setting a limit on the maximum possible gain. A SELL trailing stop limit moves with the market price, and continually recalculates the stop trigger price at a fixed amount below the market price, based on the user-defined "trailing" amount. The limit order price is also continually recalculated based on the limit offset. As the market price rises, both the stop price and the limit price rise by the trail amount and limit offset respectively, but if the stock price falls, the stop price remains unchanged, and when the stop price is hit a limit order is submitted at the last calculated limit price. A "Buy" trailing stop limit order is the mirror image of a sell trailing stop limit, and is generally used in falling markets. Products: BOND, CFD, CASH, FUT, FOP, OPT, STK, WAR </p>

</div>
</div>
<a id="a5b53ea59f1fea8f46e495c3eb3613508"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b53ea59f1fea8f46e495c3eb3613508">&#9670;&nbsp;</a></span>Volatility()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structOrder.html">Order</a> OrderSamples::Volatility </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quantity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>volatilityPercent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>volatilityType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specific to US options, investors are able to create and enter Volatility-type orders for options and combinations rather than price orders. Option traders may wish to trade and position for movements in the price of the option determined by its implied volatility. Because implied volatility is a key determinant of the premium on an option, traders position in specific contract months in an effort to take advantage of perceived changes in implied volatility arising before, during or after earnings or when company specific or broad market volatility is predicted to change. In order to create a Volatility order, clients must first create a Volatility Trader page from the Trading Tools menu and as they enter option contracts, premiums will display in percentage terms rather than premium. The buy/sell process is the same as for regular orders priced in premium terms except that the client can limit the volatility level they are willing to pay or receive. Products: FOP, OPT </p>

</div>
</div>
<a id="aa8433a1c43fd13b6e73a3edd53e0bbce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8433a1c43fd13b6e73a3edd53e0bbce">&#9670;&nbsp;</a></span>Volume_Condition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOrderCondition.html">OrderCondition</a> * OrderSamples::Volume_Condition </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>conId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>exchange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isMore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>volume</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isConjunction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>[volume_condition]</p>
<p>[volume_condition]</p>

</div>
</div>
<a id="a21dfbf48228f724a70f9e3ee6fcfc9dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21dfbf48228f724a70f9e3ee6fcfc9dd">&#9670;&nbsp;</a></span>WhatIfLimitOrder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structOrder.html">Order</a> OrderSamples::WhatIfLimitOrder </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quantity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>limitPrice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/namhooncho/axetrader/lib/IBJts_981.01/samples/Cpp/TestCppClient/<a class="el" href="OrderSamples_8h_source.html">OrderSamples.h</a></li>
<li>/home/namhooncho/axetrader/lib/IBJts_981.01/samples/Cpp/TestCppClient/<a class="el" href="OrderSamples_8cpp.html">OrderSamples.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
